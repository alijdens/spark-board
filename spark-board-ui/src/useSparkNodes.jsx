import { useMemo } from 'react';


export default function useSparkDag(nodesConfig) {
    // model_initialNodes, model_initialEdges and model_defaultSettings are defined in model.js, which is
    // included in the index.html file because this file will be generated by
    // spark_board while processing the data frame.
    // For development purposes, we also added a model.js file here in order to
    // be able to compile and execute the project.
    const baseNodes = model_initialNodes.map(node => {
        if (node.position === undefined) {
            node.position = (node.type == "transformation" ? {x: 0, y: 0} : {x: 0, y: 25});
        }

        if (node.type == "column") {
            node.draggable = false;
        }
        return node;
    });
    const baseEdges = model_initialEdges.map(edge => {
        if (edge.animated) {
            return {
                ...edge,
                style: {
                    ...edge.style,
                    strokeWidth: 3,
                    stroke: "black",
                },
            }
        }
        return edge;
    })

    const nodesAndEdges = useMemo(() => {
        let [nodes, edges] = [null, null];
        if (nodesConfig.duplicateDataSources) {
            // DAG data sources are expected to already be duplicated
            [nodes, edges] = [baseNodes, baseEdges];
        } else {
            [nodes, edges] = deduplicateDataSources(baseNodes, baseEdges);
        }

        if (nodesConfig.invertDag) {
            edges = invertEdges(edges);
        }

        return [nodes, edges];
    }, [nodesConfig.duplicateDataSources, nodesConfig.invertDag]);

    return nodesAndEdges;
}


/**
 * Merges all transformation nodes that represent the same data source.
 * For example, all data sources that represent the same table will be collapsed
 * into a single node for that table, and all transformations that are connected
 * to them will be connected to the single DS.
 * Note that Spark will create a DS node each time a transformation needs to
 * access it. For example, a join between a table and itself will create 2 DS
 * nodes for the same table connected to the join.
 * 
 * @param {list} nodes DAG nodes.
 * @param {list} edges DAG edges.
 * @returns new nodes and edges representing the DAG with merged data sources.
 */
function deduplicateDataSources(nodes, edges) {
    // STEP 1: find all repeated data sources and define which one will replace the others
    
    // data source node IDs
    const dataSourceIds = new Set();
    // data source key (string that identifies the DS) => unique data source node ID
    const dataSources = new Map();
    // data source node ID => Id of the data source node that will replace it (the unique one)
    const nodesToRemove = new Map();

    // find all repeated data sources and store them in the maps with the indication
    // of which one will replace the others
    nodes.forEach(node => {
        if (node.type == "transformation" && node.data.type == "DataSource") {
            // use the metadata to compare data sources (same JSON metadata is considered
            // as a node to the same DS)
            const key = JSON.stringify(node.data.metadata);
            if (dataSources.has(key)) {
                // this is a duplicated DS, so we store the node ID of the one that will
                // replace it
                nodesToRemove.set(node.id, dataSources.get(key));
            } else {
                // DS has not been seen so far, so we store it in the map
                dataSources.set(key, node.id);
                dataSourceIds.add(node.id);
            }
        }
    });

    // STEP 2: find the column nodes belonging to the deleted data sources
    //         and find the corresponding replacement

    // take a column node and return a string that identifies it
    // columns with the same key are considered to be the same
    function colKey(colNode) {
        return JSON.stringify({
            name: colNode.data.name,
            type: colNode.data.type,
        });
    }

    // DS node ID => Map(colKey => column node ID)
    const DSCols = new Map();
    nodes.forEach(node => {
        if (node.type == "column" && dataSourceIds.has(node.parentNode)) {
            if (!DSCols.has(node.parentNode)) {
                DSCols.set(node.parentNode, new Map());
            }
            DSCols.get(node.parentNode).set(colKey(node), node.id);
        }
    });

    // deleted column node ID => replacement column node ID
    const colsToRemove = new Map();
    nodes.forEach(node => {
        // check if it's a column that belongs to a transformation node that is deleted
        if (node.type == "column" && nodesToRemove.has(node.parentNode)) {
            const tfNodeId = nodesToRemove.get(node.parentNode);
            // store the corresponding column replacement ID
            const replacementId = DSCols.get(tfNodeId).get(colKey(node));
            colsToRemove.set(node.id, replacementId);
        }
    });
    // remove all nodes marked to be deleted
    let newNodes = nodes.filter(node => !nodesToRemove.has(node.id) && !colsToRemove.has(node.id)).map(node => {
        // now update all references to the deleted nodes by the dedeplicated ones
        switch (node.type) {
            case "transformation": return {
                ...node,
                data: {
                    ...node.data,
                    // replace column references that are going to be deleted by the new ones
                    columns: node.data.columns.map(colId => colsToRemove.get(colId) || colId),
                },
            }
            case "column": return {
                ...node,
                data: {
                    ...node.data,
                    // replace column links that are going to be deleted by the new ones
                    linked_columns: node.data.linked_columns.map(colId => colsToRemove.get(colId) || colId),
                },
            }
            default: throw new Error(`Unhandled node type "${node.type}"`)
        }
    });
    let newEdges = edges.map(edge => {
        // replace edges that point to deleted nodes by the corresponding ones
        if (nodesToRemove.has(edge.target)) {
            return { ...edge, target: nodesToRemove.get(edge.target) };
        }
        // same for columns
        if (colsToRemove.has(edge.target)) {
            return { ...edge, target: colsToRemove.get(edge.target) };
        }
        return edge;
    });

    return [newNodes, newEdges];
}

/**
 * Return the same input `edges` but inverting the source and target nodes.
 * @param {*} edges List of DAG edges.
 * @returns Same list but with edges inverted.
 */
function invertEdges(edges) {
    return edges.map(edge => ({
            ...edge,
            source: edge.target,
            target: edge.source,
        })
    );
}
