import React, { useMemo, useCallback, useEffect } from 'react';
import ReactFlow, { useNodesState, useEdgesState, MiniMap, Controls, useNodesInitialized, useReactFlow } from 'reactflow';

import TransformationNode, { getTransformationStyle } from './transformation';
import ColumnNode from './column';
import SideBar from './sidebar';
import drawColumnGraph, { useColumnGraphState } from './columnGraph';
import { buildLayout } from './dag'
import useDagAnimation from './useDagAnimation';
import CustomControls from './controls';

import 'reactflow/dist/style.css';
import './transformation.css';
import './App.css'


export default function App() {
    const { fitBounds } = useReactFlow();

    // Selected transformation node: For the time being, it's chosen with onClick because we don't 
    // want to have multiple "selected nodes"
    const [selectedTransformation, setSelectedTransformation] = React.useState(null);

    // model_initialNodes and model_initialEdges are defined in model.js, which is
    // included in the index.html file because this file will be generated by
    // spark_board while processing the data frame.
    // For development purposes, we also added a model.js file here in order to
    // be able to compile and execute the project.
    model_initialNodes.forEach(node => {
        // add a callback inside the node `data` that defines whether the node
        // is selected or not
        node.data.selected = useCallback(() => 
            // we check if the node is selected by comparing the nodes data
            selectedTransformation !== null && selectedTransformation.data == node.data
        );

        if (!node.position) {
            node.position = {x: 0, y: 0};
        }
    });

    const [nodePositions, setNodePositions] = React.useState(new Map(
        model_initialNodes.map(node => [node.id, node.position])
    ));

    const [nodes, setNodes, onNodesChange] = useNodesState(model_initialNodes);
    const [edges, setEdges, onEdgesChange] = useEdgesState(model_initialEdges);

    // Used to register the transformation and column node types into react-flow
    const nodeTypes = useMemo(() => ({
        transformation: TransformationNode,
        column: ColumnNode
    }), []);

    const nodesInitialized = useNodesInitialized();
    const [startAnimation, updateNodePositions] = useDagAnimation(nodes, edges, nodePositions, setNodes);
    useEffect(() => {
        if (nodesInitialized) {
            // calculate the node positions in the screen
            const [dagLayout, bounds] = buildLayout(model_initialEdges[0].source, model_initialEdges);
            // set the node animation to position in the layout
            setNodePositions(dagLayout);
            // set the viewport to the center of the layout
            fitBounds(bounds, { duration: 0, padding: 0.1 });
            return startAnimation();
        }
    }, [nodesInitialized]);

    // controls the column for which the column graph is shown
    const [selectedColumn, setSelectedColumn] = useColumnGraphState(null);

    // hook that renders the column graph
    drawColumnGraph(setNodes, setEdges, selectedColumn);

    // Callback to set one node as selected, and reset the column tracking
    const onNodeClick = useCallback((event, node) => {
        if (node.type == "transformation") {
            setSelectedTransformation(node);
            setSelectedColumn(null);
        }
    }, [selectedTransformation, selectedColumn]);

    return (
        <div className="app_container" style={{ width: '100vw', height: '100vh' }}>
            <SideBar width="400px" node={selectedTransformation} onSelectedColumnChange={setSelectedColumn} selectedColumn={selectedColumn} />
            <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                fitView
                nodeTypes={nodeTypes}
                onNodeClick={onNodeClick}
                fitViewOptions={{ includeHiddenNodes: true, padding: 0.1 }}
            >
                <CustomControls updateNodePositions={updateNodePositions} nodes={nodes} />
                <MiniMap zoomable pannable nodeColor={node => {
                    if (node.type == "transformation") {
                        return getTransformationStyle(node.data.type)[0];
                    }
                }} />
            </ReactFlow>
        </div>
    );
}