import { useMemo, useCallback } from 'react';


export default function useSparkDag(nodesConfig) {
    // model_initialNodes, model_initialEdges and model_defaultSettings are defined in model.js, which is
    // included in the index.html file because this file will be generated by
    // spark_board while processing the data frame.
    // For development purposes, we also added a model.js file here in order to
    // be able to compile and execute the project.
    const baseNodes = model_initialNodes.map(node => {
        if (node.position === undefined) {
            node.position = (node.type == "transformation" ? {x: 0, y: 0} : {x: 0, y: 25});
        }

        if (node.type == "column") {
            node.draggable = false;
        }
        return node;
    });
    const baseEdges = model_initialEdges.map(edge => {
        if (edge.animated) {
            return {
                ...edge,
                style: {
                    ...edge.style,
                    strokeWidth: 3,
                    stroke: "black",
                },
            }
        }
        return edge;
    })

    const nodesAndEdges = useMemo(() => {
        if (nodesConfig.duplicateDataSources) {
            // DAG data sources are expected to already be duplicated
            return [baseNodes, baseEdges];
        } else {
            return deduplicateDataSources(baseNodes, baseEdges);
        }
    }, [nodesConfig.duplicateDataSources]);

    return nodesAndEdges;
}


function deduplicateDataSources(nodes, edges) {
    const dataSourceIds = new Set();
    const dataSources = new Map();
    const nodesToRemove = new Map();

    nodes.forEach(node => {
        if (node.type == "transformation" && node.data.type == "DataSource") {
            const key = JSON.stringify(node.data.metadata);
            if (dataSources.has(key)) {
                nodesToRemove.set(node.id, dataSources.get(key));
            } else {
                dataSources.set(key, node.id);
                dataSourceIds.add(node.id);
            }
        }
    });

    function colKey(colNode) {
        return JSON.stringify({
            // id: colNode.data.id,
            name: colNode.data.name,
            type: colNode.data.type,
        });
    }

    // transformation node ID => Map(colKey => column node ID)
    const DSCols = new Map();
    nodes.forEach(node => {
        if (node.type == "column" && dataSourceIds.has(node.parentNode)) {
            if (!DSCols.has(node.parentNode)) {
                DSCols.set(node.parentNode, new Map());
            }
            DSCols.get(node.parentNode).set(colKey(node), node.id);
        }
    });

    // deleted column node ID => replacement column node ID
    const colsToRemove = new Map();
    nodes.forEach(node => {
        // check if it's a column that belongs to a transformation node that is deleted
        if (node.type == "column" && nodesToRemove.has(node.parentNode)) {
            const tfNodeId = nodesToRemove.get(node.parentNode);
            // store the corresponding column replacement ID
            const replacementId = DSCols.get(tfNodeId).get(colKey(node));
            colsToRemove.set(node.id, replacementId);
        }
    });
    let newNodes = nodes.filter(node => !nodesToRemove.has(node.id) && !colsToRemove.has(node.id)).map(node => {
        switch (node.type) {
            case "transformation": return {
                ...node,
                data: {
                    ...node.data,
                    // replace column references that are going to be deleted by the new ones
                    columns: node.data.columns.map(colId => colsToRemove.get(colId) || colId),
                },
            }
            case "column": return {
                ...node,
                data: {
                    ...node.data,
                    // replace column links that are going to be deleted by the new ones
                    linked_columns: node.data.linked_columns.map(colId => colsToRemove.get(colId) || colId),
                },
            }
            default: throw new Error(`Unhandled node type "${node.type}"`)
        }
    });
    let newEdges = edges.map(edge => {
        // replace edges that point to deleted nodes by the corresponding ones
        if (nodesToRemove.has(edge.target)) {
            return { ...edge, target: nodesToRemove.get(edge.target) };
        }
        // same for columns
        if (colsToRemove.has(edge.target)) {
            return { ...edge, target: colsToRemove.get(edge.target) };
        }
        return edge;
    });

    return [newNodes, invertEdges(newEdges)];
}

/**
 * Return the same input `edges` but inverting the source and target nodes.
 * @param {*} edges List of DAG edges.
 * @returns Same list but with edges inverted.
 */
function invertEdges(edges) {
    return edges.map(edge => ({
            ...edge,
            source: edge.target,
            target: edge.source,
        })
    );
}
